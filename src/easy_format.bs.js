// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("@rescript/std/lib/js/list.js");
var Curry = require("@rescript/std/lib/js/curry.js");
var $$Buffer = require("@rescript/std/lib/js/buffer.js");
var Format = require("@rescript/std/lib/js/format.js");
var Printf = require("@rescript/std/lib/js/printf.js");
var $$String = require("@rescript/std/lib/js/string.js");
var Hashtbl = require("@rescript/std/lib/js/hashtbl.js");
var Pervasives = require("@rescript/std/lib/js/pervasives.js");
var Caml_js_exceptions = require("@rescript/std/lib/js/caml_js_exceptions.js");

function rev_split(l) {
  var _xs = /* [] */0;
  var _ys = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var ys = _ys;
    var xs = _xs;
    if (!param) {
      return [
              xs,
              ys
            ];
    }
    var match = param.hd;
    _param = param.tl;
    _ys = {
      hd: match[1],
      tl: ys
    };
    _xs = {
      hd: match[0],
      tl: xs
    };
    continue ;
  };
}

function propagate_from_leaf_to_root(init_acc, merge_acc, map_node, x) {
  var aux = function (x) {
    switch (x.TAG | 0) {
      case /* List */1 :
          var match = rev_split(List.rev_map(aux, x._1));
          var acc = List.fold_left(merge_acc, Curry._1(init_acc, x), match[1]);
          return Curry._2(map_node, {
                      TAG: /* List */1,
                      _0: x._0,
                      _1: match[0]
                    }, acc);
      case /* Label */2 :
          var match$1 = x._0;
          var acc0 = Curry._1(init_acc, x);
          var match$2 = aux(match$1[0]);
          var match$3 = aux(x._1);
          var acc$1 = Curry._2(merge_acc, Curry._2(merge_acc, acc0, match$2[1]), match$3[1]);
          return Curry._2(map_node, {
                      TAG: /* Label */2,
                      _0: [
                        match$2[0],
                        match$1[1]
                      ],
                      _1: match$3[0]
                    }, acc$1);
      case /* Atom */0 :
      case /* Custom */3 :
          break;
      
    }
    var acc$2 = Curry._1(init_acc, x);
    return Curry._2(map_node, x, acc$2);
  };
  return aux(x);
}

function propagate_forced_breaks(x) {
  var init_acc = function (param) {
    switch (param.TAG | 0) {
      case /* List */1 :
          return param._0[3].wrap_body === "Force_breaks_rec";
      case /* Label */2 :
          return param._0[1].label_break === "Always_rec";
      case /* Atom */0 :
      case /* Custom */3 :
          return false;
      
    }
  };
  var merge_acc = function (force_breaks1, force_breaks2) {
    if (force_breaks1) {
      return true;
    } else {
      return force_breaks2;
    }
  };
  var map_node = function (x, force_breaks) {
    switch (x.TAG | 0) {
      case /* List */1 :
          var match = x._0;
          var p = match[3];
          var match$1 = p.wrap_body;
          if (match$1 === "No_breaks") {
            return [
                    x,
                    force_breaks
                  ];
          }
          if (match$1 === "Force_breaks_rec") {
            return [
                    x,
                    true
                  ];
          }
          if (match$1 === "Force_breaks") {
            return [
                    x,
                    force_breaks
                  ];
          }
          if (!force_breaks) {
            return [
                    x,
                    false
                  ];
          }
          var p_space_after_opening = p.space_after_opening;
          var p_space_after_separator = p.space_after_separator;
          var p_space_before_separator = p.space_before_separator;
          var p_separators_stick_left = p.separators_stick_left;
          var p_space_before_closing = p.space_before_closing;
          var p_stick_to_label = p.stick_to_label;
          var p_align_closing = p.align_closing;
          var p_indent_body = p.indent_body;
          var p_list_style = p.list_style;
          var p_opening_style = p.opening_style;
          var p_body_style = p.body_style;
          var p_separator_style = p.separator_style;
          var p_closing_style = p.closing_style;
          var p$1 = {
            space_after_opening: p_space_after_opening,
            space_after_separator: p_space_after_separator,
            space_before_separator: p_space_before_separator,
            separators_stick_left: p_separators_stick_left,
            space_before_closing: p_space_before_closing,
            stick_to_label: p_stick_to_label,
            align_closing: p_align_closing,
            wrap_body: "Force_breaks",
            indent_body: p_indent_body,
            list_style: p_list_style,
            opening_style: p_opening_style,
            body_style: p_body_style,
            separator_style: p_separator_style,
            closing_style: p_closing_style
          };
          return [
                  {
                    TAG: /* List */1,
                    _0: [
                      match[0],
                      match[1],
                      match[2],
                      p$1
                    ],
                    _1: x._1
                  },
                  true
                ];
      case /* Label */2 :
          var match$2 = x._0;
          var lp = match$2[1];
          if (lp.label_break !== "Auto") {
            return [
                    x,
                    force_breaks
                  ];
          }
          if (!force_breaks) {
            return [
                    x,
                    false
                  ];
          }
          var lp_space_after_label = lp.space_after_label;
          var lp_indent_after_label = lp.indent_after_label;
          var lp_label_style = lp.label_style;
          var lp$1 = {
            label_break: "Always",
            space_after_label: lp_space_after_label,
            indent_after_label: lp_indent_after_label,
            label_style: lp_label_style
          };
          return [
                  {
                    TAG: /* Label */2,
                    _0: [
                      match$2[0],
                      lp$1
                    ],
                    _1: x._1
                  },
                  true
                ];
      case /* Atom */0 :
      case /* Custom */3 :
          return [
                  x,
                  force_breaks
                ];
      
    }
  };
  return propagate_from_leaf_to_root(init_acc, merge_acc, map_node, x)[0];
}

function set_escape(fmt, $$escape) {
  var match = Format.pp_get_formatter_output_functions(fmt, undefined);
  var print0 = match[0];
  var tagf0 = Format.pp_get_formatter_tag_functions(fmt, undefined);
  var is_tag = {
    contents: false
  };
  var mot = function (tag) {
    is_tag.contents = true;
    return Curry._1(tagf0.mark_open_tag, tag);
  };
  var mct = function (tag) {
    is_tag.contents = true;
    return Curry._1(tagf0.mark_close_tag, tag);
  };
  var print = function (s, p, n) {
    if (is_tag.contents) {
      Curry._3(print0, s, p, n);
      is_tag.contents = false;
      return ;
    } else {
      return Curry._4($$escape, print0, s, p, n);
    }
  };
  var tagf_print_open_tag = tagf0.print_open_tag;
  var tagf_print_close_tag = tagf0.print_close_tag;
  var tagf = {
    mark_open_tag: mot,
    mark_close_tag: mct,
    print_open_tag: tagf_print_open_tag,
    print_close_tag: tagf_print_close_tag
  };
  Format.pp_set_formatter_output_functions(fmt, print, match[1]);
  return Format.pp_set_formatter_tag_functions(fmt, tagf);
}

function define_styles(fmt, $$escape, l) {
  if (l !== /* [] */0) {
    Format.pp_set_tags(fmt, true);
    var tbl1 = Hashtbl.create(undefined, (List.length(l) << 1));
    var tbl2 = Hashtbl.create(undefined, (List.length(l) << 1));
    List.iter((function (param) {
            var style = param[1];
            var style_name = param[0];
            Hashtbl.add(tbl1, style_name, style.tag_open);
            return Hashtbl.add(tbl2, style_name, style.tag_close);
          }), l);
    var mark_open_tag = function (style_name) {
      try {
        return Hashtbl.find(tbl1, style_name);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return "";
        }
        throw exn;
      }
    };
    var mark_close_tag = function (style_name) {
      try {
        return Hashtbl.find(tbl2, style_name);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return "";
        }
        throw exn;
      }
    };
    var init = Format.pp_get_formatter_tag_functions(fmt, undefined);
    var tagf_print_open_tag = init.print_open_tag;
    var tagf_print_close_tag = init.print_close_tag;
    var tagf = {
      mark_open_tag: mark_open_tag,
      mark_close_tag: mark_close_tag,
      print_open_tag: tagf_print_open_tag,
      print_close_tag: tagf_print_close_tag
    };
    Format.pp_set_formatter_tag_functions(fmt, tagf);
  }
  if (typeof $$escape === "string") {
    return ;
  } else if ($$escape.NAME === "Escape") {
    return set_escape(fmt, $$escape.VAL);
  } else {
    var esc = $$escape.VAL;
    var $$escape$1 = function (print, s, p, n) {
      var s0 = $$String.sub(s, p, n);
      var s1 = Curry._1(esc, s0);
      return Curry._3(print, s1, 0, s1.length);
    };
    return set_escape(fmt, $$escape$1);
  }
}

function pp_open_xbox(fmt, p, indent) {
  var match = p.wrap_body;
  if (match === "No_breaks") {
    return Format.pp_open_hbox(fmt, undefined);
  } else if (match === "Force_breaks" || match === "Force_breaks_rec") {
    return Format.pp_open_vbox(fmt, indent);
  } else {
    return Format.pp_open_hvbox(fmt, indent);
  }
}

function extra_box(p, l) {
  var match = p.wrap_body;
  var wrap = match === "Never_wrap" || match === "Force_breaks" || match === "Force_breaks_rec" || match === "No_breaks" ? false : (
      match === "Always_wrap" ? true : List.for_all((function (param) {
                if (param.TAG === /* Atom */0) {
                  return true;
                } else {
                  return false;
                }
              }), l)
    );
  if (wrap) {
    return [
            (function (fmt) {
                return Format.pp_open_hovbox(fmt, 0);
              }),
            (function (fmt) {
                return Format.pp_close_box(fmt, undefined);
              })
          ];
  } else {
    return [
            (function (param) {
                
              }),
            (function (param) {
                
              })
          ];
  }
}

function pp_open_nonaligned_box(fmt, p, indent, l) {
  var match = p.wrap_body;
  if (match === "No_breaks") {
    return Format.pp_open_hbox(fmt, undefined);
  } else if (match === "Force_breaks" || match === "Force_breaks_rec") {
    return Format.pp_open_vbox(fmt, indent);
  } else if (match === "Never_wrap" || !(match === "Always_wrap" || List.for_all((function (param) {
              return param.TAG === /* Atom */0 ? true : false;
            }), l))) {
    return Format.pp_open_hvbox(fmt, indent);
  } else {
    return Format.pp_open_hovbox(fmt, indent);
  }
}

function open_tag(fmt, s) {
  if (s !== undefined) {
    return Format.pp_open_tag(fmt, s);
  }
  
}

function close_tag(fmt, param) {
  if (param !== undefined) {
    return Format.pp_close_tag(fmt, undefined);
  }
  
}

function tag_string(fmt, o, s) {
  if (o !== undefined) {
    Format.pp_open_tag(fmt, o);
    Format.pp_print_string(fmt, s);
    return Format.pp_close_tag(fmt, undefined);
  } else {
    return Format.pp_print_string(fmt, s);
  }
}

function fprint_t(fmt, f) {
  switch (f.TAG | 0) {
    case /* Atom */0 :
        return tag_string(fmt, f._1.atom_style, f._0);
    case /* List */1 :
        var l = f._1;
        var param = f._0;
        var p = param[3];
        open_tag(fmt, p.list_style);
        if (p.align_closing) {
          fprint_list(fmt, undefined, param, l);
        } else {
          fprint_list2(fmt, param, l);
        }
        return close_tag(fmt, p.list_style);
    case /* Label */2 :
        var label = f._0;
        var x = f._1;
        var lp = label[1];
        if (x.TAG === /* List */1) {
          var match = x._0;
          var p$1 = match[3];
          if (p$1.stick_to_label && p$1.align_closing) {
            return fprint_list(fmt, label, [
                        match[0],
                        match[1],
                        match[2],
                        p$1
                      ], x._1);
          }
          
        }
        var indent = lp.indent_after_label;
        Format.pp_open_hvbox(fmt, 0);
        open_tag(fmt, lp.label_style);
        fprint_t(fmt, label[0]);
        close_tag(fmt, lp.label_style);
        var match$1 = lp.label_break;
        if (match$1 === "Auto") {
          if (lp.space_after_label) {
            Format.pp_print_break(fmt, 1, indent);
          } else {
            Format.pp_print_break(fmt, 0, indent);
          }
        } else if (match$1 === "Never") {
          if (lp.space_after_label) {
            Format.pp_print_char(fmt, /* ' ' */32);
          }
          
        } else {
          Format.pp_force_newline(fmt, undefined);
          Format.pp_print_string(fmt, $$String.make(indent, /* ' ' */32));
        }
        fprint_t(fmt, x);
        return Format.pp_close_box(fmt, undefined);
    case /* Custom */3 :
        return Curry._1(f._0, fmt);
    
  }
}

function fprint_list_body_stick_left(fmt, p, sep, hd, tl) {
  open_tag(fmt, p.body_style);
  fprint_t(fmt, hd);
  List.iter((function (x) {
          if (p.space_before_separator) {
            Format.pp_print_string(fmt, " ");
          }
          tag_string(fmt, p.separator_style, sep);
          if (p.space_after_separator) {
            Format.pp_print_space(fmt, undefined);
          } else {
            Format.pp_print_cut(fmt, undefined);
          }
          return fprint_t(fmt, x);
        }), tl);
  return close_tag(fmt, p.body_style);
}

function fprint_list_body_stick_right(fmt, p, sep, hd, tl) {
  open_tag(fmt, p.body_style);
  fprint_t(fmt, hd);
  List.iter((function (x) {
          if (p.space_before_separator) {
            Format.pp_print_space(fmt, undefined);
          } else {
            Format.pp_print_cut(fmt, undefined);
          }
          tag_string(fmt, p.separator_style, sep);
          if (p.space_after_separator) {
            Format.pp_print_string(fmt, " ");
          }
          return fprint_t(fmt, x);
        }), tl);
  return close_tag(fmt, p.body_style);
}

function fprint_opt_label(fmt, param) {
  if (param === undefined) {
    return ;
  }
  var lp = param[1];
  open_tag(fmt, lp.label_style);
  fprint_t(fmt, param[0]);
  close_tag(fmt, lp.label_style);
  if (lp.space_after_label) {
    return Format.pp_print_string(fmt, " ");
  }
  
}

function fprint_list(fmt, label, param, l) {
  var p = param[3];
  if (l) {
    var tl = l.tl;
    var hd = l.hd;
    if (tl === /* [] */0 || p.separators_stick_left) {
      var p$1 = param[3];
      var indent = p$1.indent_body;
      pp_open_xbox(fmt, p$1, indent);
      fprint_opt_label(fmt, label);
      tag_string(fmt, p$1.opening_style, param[0]);
      if (p$1.space_after_opening) {
        Format.pp_print_space(fmt, undefined);
      } else {
        Format.pp_print_cut(fmt, undefined);
      }
      var match = extra_box(p$1, l);
      Curry._1(match[0], fmt);
      fprint_list_body_stick_left(fmt, p$1, param[1], hd, tl);
      Curry._1(match[1], fmt);
      if (p$1.space_before_closing) {
        Format.pp_print_break(fmt, 1, -indent | 0);
      } else {
        Format.pp_print_break(fmt, 0, -indent | 0);
      }
      tag_string(fmt, p$1.closing_style, param[2]);
      return Format.pp_close_box(fmt, undefined);
    } else {
      var p$2 = param[3];
      var sep = param[1];
      var base_indent = p$2.indent_body;
      var sep_indent = sep.length + (
        p$2.space_after_separator ? 1 : 0
      ) | 0;
      var indent$1 = base_indent + sep_indent | 0;
      pp_open_xbox(fmt, p$2, indent$1);
      fprint_opt_label(fmt, label);
      tag_string(fmt, p$2.opening_style, param[0]);
      if (p$2.space_after_opening) {
        Format.pp_print_space(fmt, undefined);
      } else {
        Format.pp_print_cut(fmt, undefined);
      }
      var match$1 = extra_box(p$2, l);
      Curry._1(match$1[0], fmt);
      fprint_t(fmt, hd);
      List.iter((function (x) {
              if (p$2.space_before_separator) {
                Format.pp_print_break(fmt, 1, -sep_indent | 0);
              } else {
                Format.pp_print_break(fmt, 0, -sep_indent | 0);
              }
              tag_string(fmt, p$2.separator_style, sep);
              if (p$2.space_after_separator) {
                Format.pp_print_string(fmt, " ");
              }
              return fprint_t(fmt, x);
            }), tl);
      Curry._1(match$1[1], fmt);
      if (p$2.space_before_closing) {
        Format.pp_print_break(fmt, 1, -indent$1 | 0);
      } else {
        Format.pp_print_break(fmt, 0, -indent$1 | 0);
      }
      tag_string(fmt, p$2.closing_style, param[2]);
      return Format.pp_close_box(fmt, undefined);
    }
  }
  fprint_opt_label(fmt, label);
  tag_string(fmt, p.opening_style, param[0]);
  if (p.space_after_opening || p.space_before_closing) {
    Format.pp_print_string(fmt, " ");
  }
  return tag_string(fmt, p.closing_style, param[2]);
}

function fprint_list2(fmt, param, l) {
  var p = param[3];
  var cl = param[2];
  var sep = param[1];
  var op = param[0];
  if (l) {
    var tl = l.tl;
    var hd = l.hd;
    tag_string(fmt, p.opening_style, op);
    if (p.space_after_opening) {
      Format.pp_print_string(fmt, " ");
    }
    pp_open_nonaligned_box(fmt, p, 0, l);
    if (p.separators_stick_left) {
      fprint_list_body_stick_left(fmt, p, sep, hd, tl);
    } else {
      fprint_list_body_stick_right(fmt, p, sep, hd, tl);
    }
    Format.pp_close_box(fmt, undefined);
    if (p.space_before_closing) {
      Format.pp_print_string(fmt, " ");
    }
    return tag_string(fmt, p.closing_style, cl);
  }
  tag_string(fmt, p.opening_style, op);
  if (p.space_after_opening || p.space_before_closing) {
    Format.pp_print_string(fmt, " ");
  }
  return tag_string(fmt, p.closing_style, cl);
}

function to_formatter(fmt, x) {
  var x$1 = propagate_forced_breaks(x);
  fprint_t(fmt, x$1);
  return Format.pp_print_flush(fmt, undefined);
}

function to_buffer(escapeOpt, stylesOpt, buf, x) {
  var $$escape = escapeOpt !== undefined ? escapeOpt : "None";
  var styles = stylesOpt !== undefined ? stylesOpt : /* [] */0;
  var fmt = Format.formatter_of_buffer(buf);
  define_styles(fmt, $$escape, styles);
  return to_formatter(fmt, x);
}

function to_string($$escape, styles, x) {
  var buf = $$Buffer.create(500);
  to_buffer($$escape, styles, buf, x);
  return $$Buffer.contents(buf);
}

function to_channel(escapeOpt, stylesOpt, oc, x) {
  var $$escape = escapeOpt !== undefined ? escapeOpt : "None";
  var styles = stylesOpt !== undefined ? stylesOpt : /* [] */0;
  var fmt = Format.formatter_of_out_channel(oc);
  define_styles(fmt, $$escape, styles);
  return to_formatter(fmt, x);
}

function to_stdout($$escape, styles, x) {
  return to_channel($$escape, styles, Pervasives.stdout, x);
}

function to_stderr($$escape, styles, x) {
  return to_channel($$escape, styles, Pervasives.stderr, x);
}

function fprint_t$1(buf, f) {
  switch (f.TAG | 0) {
    case /* Atom */0 :
        return $$Buffer.add_string(buf, f._0);
    case /* List */1 :
        var param = f._0;
        var param$1 = f._1;
        var cl = param[2];
        var sep = param[1];
        var op = param[0];
        if (param$1) {
          $$Buffer.add_string(buf, op);
          fprint_t$1(buf, param$1.hd);
          List.iter((function (x) {
                  $$Buffer.add_string(buf, sep);
                  return fprint_t$1(buf, x);
                }), param$1.tl);
          return $$Buffer.add_string(buf, cl);
        } else {
          return Curry._2(Printf.bprintf(buf, /* Format */{
                          _0: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          },
                          _1: "%s%s"
                        }), op, cl);
        }
    case /* Label */2 :
        var param$2 = f._0;
        var x = f._1;
        fprint_t$1(buf, param$2[0]);
        return fprint_t$1(buf, x);
    case /* Custom */3 :
        var fmt = Format.formatter_of_buffer(buf);
        Curry._1(f._0, fmt);
        return Format.pp_print_flush(fmt, undefined);
    
  }
}

var to_buffer$1 = fprint_t$1;

function to_string$1(x) {
  var buf = $$Buffer.create(500);
  fprint_t$1(buf, x);
  return $$Buffer.contents(buf);
}

function to_formatter$1(fmt, x) {
  var s = to_string$1(x);
  Curry._1(Format.fprintf(fmt, /* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: /* End_of_format */0
            },
            _1: "%s"
          }), s);
  return Format.pp_print_flush(fmt, undefined);
}

function to_channel$1(oc, x) {
  var buf = $$Buffer.create(500);
  fprint_t$1(buf, x);
  return $$Buffer.output_buffer(oc, buf);
}

function to_stdout$1(x) {
  return to_channel$1(Pervasives.stdout, x);
}

function to_stderr$1(x) {
  return to_channel$1(Pervasives.stderr, x);
}

var atom = {
  atom_style: undefined
};

var list = {
  space_after_opening: true,
  space_after_separator: true,
  space_before_separator: false,
  separators_stick_left: true,
  space_before_closing: true,
  stick_to_label: true,
  align_closing: true,
  wrap_body: "Wrap_atoms",
  indent_body: 2,
  list_style: undefined,
  opening_style: undefined,
  body_style: undefined,
  separator_style: undefined,
  closing_style: undefined
};

var label = {
  label_break: "Auto",
  space_after_label: true,
  indent_after_label: 2,
  label_style: undefined
};

var Pretty = {
  define_styles: define_styles,
  to_formatter: to_formatter,
  to_buffer: to_buffer,
  to_string: to_string,
  to_channel: to_channel,
  to_stdout: to_stdout,
  to_stderr: to_stderr
};

var Compact = {
  to_buffer: to_buffer$1,
  to_string: to_string$1,
  to_channel: to_channel$1,
  to_stdout: to_stdout$1,
  to_stderr: to_stderr$1,
  to_formatter: to_formatter$1
};

var Param_list_true = {
  space_after_opening: true,
  space_after_separator: true,
  space_before_separator: true,
  separators_stick_left: true,
  space_before_closing: true,
  stick_to_label: true,
  align_closing: true,
  wrap_body: "Wrap_atoms",
  indent_body: 2,
  list_style: undefined,
  opening_style: undefined,
  body_style: undefined,
  separator_style: undefined,
  closing_style: undefined
};

var Param_label_true = {
  label_break: "Auto",
  space_after_label: true,
  indent_after_label: 2,
  label_style: undefined
};

var Param_list_false = {
  space_after_opening: false,
  space_after_separator: false,
  space_before_separator: false,
  separators_stick_left: false,
  space_before_closing: false,
  stick_to_label: false,
  align_closing: false,
  wrap_body: "Wrap_atoms",
  indent_body: 2,
  list_style: undefined,
  opening_style: undefined,
  body_style: undefined,
  separator_style: undefined,
  closing_style: undefined
};

var Param_label_false = {
  label_break: "Auto",
  space_after_label: false,
  indent_after_label: 2,
  label_style: undefined
};

var Param = {
  list_true: Param_list_true,
  label_true: Param_label_true,
  list_false: Param_list_false,
  label_false: Param_label_false
};

exports.atom = atom;
exports.list = list;
exports.label = label;
exports.Pretty = Pretty;
exports.Compact = Compact;
exports.Param = Param;
/* Format Not a pure module */
